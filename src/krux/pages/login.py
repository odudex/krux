# The MIT License (MIT)


# Copyright (c) 2021-2024 Krux contributors

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import sys
from embit.networks import NETWORKS
from . import (
    Menu,
    MENU_CONTINUE,
    MENU_EXIT,
    LETTERS,
    EXTRA_MNEMONIC_LENGTH_FLAG,
)
from .mnemonic_loader import MnemonicLoader
from ..display import DEFAULT_PADDING, FONT_HEIGHT, BOTTOM_PROMPT_LINE
from ..krux_settings import Settings
from ..key import (
    Key,
    P2WPKH,
    P2WSH,
    P2SH,
    SINGLESIG_SCRIPT_MAP,
    MULTISIG_SCRIPT_MAP,
    MINISCRIPT_SCRIPT_MAP,
    TYPE_SINGLESIG,
    TYPE_MULTISIG,
    TYPE_MINISCRIPT,
    POLICY_TYPE_IDS,
    NAME_MULTISIG,
)
from ..krux_settings import t
from ..kboard import kboard


DIGITS_HEX = "0123456789ABCDEF"
DIGITS_OCT = "01234567"

DOUBLE_MNEMONICS_MAX_TRIES = 200
MASK256 = (1 << 256) - 1
MASK128 = (1 << 128) - 1


class Login(MnemonicLoader):
    """Represents the login page of the app"""

    # Used on boot.py when changing the locale on Settings
    SETTINGS_MENU_INDEX = 2

    def __init__(self, ctx):
        login_menu_items = [
            (t("Load Mnemonic"), self.load_key),
            (
                t("New Mnemonic"),
                (self.new_key if not Settings().security.hide_mnemonic else None),
            ),
            (t("Settings"), self.settings),
            (t("Tools"), self.tools),
            (t("About"), self.about),
        ]
        if ctx.power_manager is not None:
            kboard.has_battery = ctx.power_manager.has_battery()
        if kboard.has_battery:
            login_menu_items.append((t("Shutdown"), self.shutdown))

        super().__init__(
            ctx,
            Menu(
                ctx,
                login_menu_items,
                back_label=None,
            ),
        )

    def new_key(self):
        """Handler for the 'new mnemonic' menu item"""
        submenu = Menu(
            self.ctx,
            [
                (t("Via Camera"), self.new_key_from_snapshot),
                (t("Via Words"), lambda: self.load_key_from_text(new=True)),
                (t("Via D6"), self.new_key_from_dice),
                (t("Via D20"), lambda: self.new_key_from_dice(True)),
            ],
        )
        index, status = submenu.run_loop()
        if index == submenu.back_index:
            return MENU_CONTINUE
        return status

    def new_key_from_dice(self, d_20=False):
        """Handler for both 'new mnemonic'>'via D6/D20' menu items. Default is D6"""
        from .new_mnemonic.dice_rolls import DiceEntropy

        dice_entropy = DiceEntropy(self.ctx, d_20)
        captured_entropy = dice_entropy.new_key()
        if captured_entropy is not None:
            from embit.bip39 import mnemonic_from_bytes

            words = mnemonic_from_bytes(captured_entropy).split()
            return self._load_key_from_words(words, new=True)
        return MENU_CONTINUE

    def new_key_from_snapshot(self):
        """Use camera's entropy to create a new mnemonic"""
        extra_option = t("Double mnemonic")
        len_mnemonic = self.choose_len_mnemonic(extra_option)
        if not len_mnemonic:
            return MENU_CONTINUE

        self.ctx.display.draw_hcentered_text(
            t("Use camera's entropy to create a new mnemonic")
            + ". "
            + t("(Experimental)")
        )
        if self.prompt(t("Proceed?"), BOTTOM_PROMPT_LINE):
            from .capture_entropy import CameraEntropy

            camera_entropy = CameraEntropy(self.ctx)
            entropy_bytes = camera_entropy.capture()
            if entropy_bytes is not None:
                import binascii
                from embit.bip39 import mnemonic_from_bytes
                from ..bip39 import entropy_checksum

                entropy_hash = binascii.hexlify(entropy_bytes).decode()
                self.ctx.display.clear()
                self.ctx.display.draw_centered_text(
                    t("SHA256 of snapshot:") + "\n\n%s" % entropy_hash,
                    highlight_prefix=":",
                )
                self.ctx.input.wait_for_button()

                # Checks if user wants to create a double mnemonic
                if len_mnemonic == EXTRA_MNEMONIC_LENGTH_FLAG:
                    # import time  # Debug
                    # pre_t = time.ticks_ms()  # Debug

                    # split the mnemonic into two parts
                    first_12_entropy = entropy_bytes[:16]
                    second_12_entropy = entropy_bytes[16:32]

                    # calculate the checksum for the first 12 words
                    checksum1 = entropy_checksum(first_12_entropy, 4)
                    # print first 12 words

                    # replace checksum1 as first 4 bits of second 12 words
                    snd_12_array = bytearray(second_12_entropy)
                    snd_12_array[0] = (snd_12_array[0] & 0x0F) | (
                        (checksum1 & 0x0F) << 4
                    )
                    second_12_entropy = bytes(snd_12_array)
                    # reassemble the 256 bits entropy that has first 12 words with valid checksum
                    entropy_bytes = first_12_entropy + second_12_entropy

                    # Increment 1 to full 24 words entropy until
                    # both last 12 words and all 24 have valid checksum
                    tries = 0
                    entropy_int = int.from_bytes(entropy_bytes, "big")
                    while True:
                        # calculate the checksum for the new 24 words
                        ck_sum_24 = entropy_checksum(entropy_bytes, 8)

                        # Extract the lower 128 bits from the integer.
                        snd_12_int = entropy_int & MASK128
                        # Shift and combine with first 4 bits of the 24 wwords checksum
                        shifted_entr = ((snd_12_int << 4) & MASK128) | (ck_sum_24 >> 4)
                        shifted_entropy_bytes = shifted_entr.to_bytes(16, "big")
                        checksum_l_12 = entropy_checksum(shifted_entropy_bytes, 4)
                        # check if checksum_l_12 is equal to the last 4 bits of the
                        # checksum of the full 24 words
                        if checksum_l_12 == (ck_sum_24 & 0x0F):
                            break

                        # Increment the integer value and mask to 256 bits.
                        entropy_int = (entropy_int + 1) & MASK256
                        entropy_bytes = entropy_int.to_bytes(32, "big")
                        tries += 1
                        if tries > DOUBLE_MNEMONICS_MAX_TRIES:
                            raise ValueError("Failed to find a valid double mnemonic")
                    # print("Tries: {} / {} ms".format(tries, time.ticks_ms() - pre_t))  # Debug

                num_bytes = 16 if len_mnemonic == 12 else 32
                entropy_mnemonic = mnemonic_from_bytes(entropy_bytes[:num_bytes])
                return self._load_key_from_words(entropy_mnemonic.split(), new=True)
        return MENU_CONTINUE

    def _load_key_from_words(self, words, charset=LETTERS, new=False):
        mnemonic = " ".join(words)

        # Don't show word list confirmation or the mnemonic editor if hide mnemonic is enabled
        if not Settings().security.hide_mnemonic:
            if charset != LETTERS:
                if self._confirm_key_from_digits(mnemonic, charset) is not None:
                    return MENU_CONTINUE

            from .mnemonic_editor import MnemonicEditor

            mnemonic = MnemonicEditor(self.ctx, mnemonic, new).edit()
        if mnemonic is None:
            return MENU_CONTINUE

        passphrase = ""
        if not hasattr(Settings().wallet, "policy_type") and hasattr(
            Settings().wallet, "multisig"
        ):
            # Retro compatibility with old settings - Multisig (false or true)
            if Settings().wallet.multisig:
                Settings().wallet.policy_type = NAME_MULTISIG

        # New settings - Policy type (single-sig, multisig, miniscript)
        policy_type = POLICY_TYPE_IDS.get(Settings().wallet.policy_type, TYPE_SINGLESIG)
        network = NETWORKS[Settings().wallet.network]
        account = 0

        # If single-sig, by default we use p2wpkh
        # but respect the script type setting
        # in default wallet settings
        if policy_type == TYPE_SINGLESIG:
            script_type = SINGLESIG_SCRIPT_MAP.get(
                Settings().wallet.script_type, P2WPKH
            )

        # If multi-sig, by default we use p2wsh
        # but respect the script type setting
        # in default wallet settings, but if we're
        # using P2SH, we don't use, by default,
        # an account (m/45')
        if policy_type == TYPE_MULTISIG:
            script_type = MULTISIG_SCRIPT_MAP.get(Settings().wallet.script_type, P2WSH)
            if script_type == P2SH:
                account = None

        # If miniscript, by default we use p2wsh
        # but respect the script type setting
        # in default wallet settings
        if policy_type == TYPE_MINISCRIPT:
            script_type = MINISCRIPT_SCRIPT_MAP.get(
                Settings().wallet.script_type, P2WSH
            )

        derivation_path = ""

        from ..wallet import Wallet
        from ..themes import theme
        from .utils import Utils

        utils = Utils(self.ctx)
        while True:
            key = Key(
                mnemonic,
                policy_type,
                network,
                passphrase,
                account,
                script_type,
                derivation_path,
            )
            network_name = network["name"]
            if not derivation_path:
                derivation_path = key.derivation

            wallet_info = "\n" + utils.generate_wallet_info(
                network_name, policy_type, script_type, derivation_path, True
            )
            wallet_info += "\n" + (
                t("No Passphrase")
                if not passphrase
                else t("Passphrase") + " (%d): *…*" % len(passphrase)
            )

            self.ctx.display.clear()
            submenu = Menu(
                self.ctx,
                [
                    (t("Load Wallet"), lambda: None),
                    (t("Passphrase"), lambda: None),
                    (t("Customize"), lambda: None),
                ],
                offset=(
                    self.ctx.display.draw_hcentered_text(wallet_info, info_box=True)
                    * FONT_HEIGHT
                    + DEFAULT_PADDING
                ),
            )

            # draw fingerprint with highlight color
            self.ctx.display.draw_hcentered_text(
                key.fingerprint_hex_str(True),
                color=theme.highlight_color,
                bg_color=theme.info_bg_color,
            )

            # draw network with highlight color
            self.ctx.display.draw_hcentered_text(
                network_name,
                DEFAULT_PADDING + FONT_HEIGHT,
                color=Utils.get_network_color(network_name),
                bg_color=theme.info_bg_color,
            )

            index, _ = submenu.run_loop()
            if index == submenu.back_index:
                if self.prompt(t("Are you sure?"), self.ctx.display.height() // 2):
                    del key
                    return MENU_CONTINUE
            if index == 0:
                break
            if index == 1:
                from .wallet_settings import PassphraseEditor

                passphrase_editor = PassphraseEditor(self.ctx)
                temp_passphrase = passphrase_editor.load_passphrase_menu(mnemonic)
                if temp_passphrase is not None:
                    passphrase = temp_passphrase
            elif index == 2:
                from .wallet_settings import WalletSettings

                wallet_settings = WalletSettings(self.ctx)
                network, policy_type, script_type, account, derivation_path = (
                    wallet_settings.customize_wallet(key)
                )

        self.ctx.display.clear()
        self.ctx.display.draw_centered_text(t("Loading…"))

        self.ctx.wallet = Wallet(key)
        return MENU_EXIT

    def tools(self):
        """Handler for the 'Tools' menu item"""
        from .tools import Tools

        while True:
            if Tools(self.ctx).run() == MENU_EXIT:
                break

        # Unimport tools
        sys.modules.pop("krux.pages.tools")
        del sys.modules["krux.pages"].tools

        return MENU_CONTINUE

    def settings(self):
        """Handler for the 'settings' menu item"""
        from .settings_page import SettingsPage

        settings_page = SettingsPage(self.ctx)
        return settings_page.settings()

    def about(self):
        """Handler for the 'about' menu item"""

        TEST_DATA_BYTES = b'psbt\xff\x01\x00q\x02\x00\x00\x00\x01\xcf<X\xc3)\x82\xae P\x88\xd9\xbdI\xeb\x9b\x02\xac\xdfM=\xaev\xa5\x16\xc6\xb3\x06\xb1]\xe3\xa1N\x00\x00\x00\x00\x00\xfd\xff\xff\xff\x02|?]\x05\x00\x00\x00\x00\x16\x00\x14/4\xaa\x1c\xf0\nS\xb0U\xa2\x91\xa0:}E\xf0\xa6\x98\x8bR\x80\x96\x98\x00\x00\x00\x00\x00\x16\x00\x14\xe6j\xfe\xff\xc3\x83\x8eq\xf0\xa2{\x07\xe3\xb0\x0e\xdej\xe8\xe1`\x00\x00\x00\x00\x00\x01\x01\x1f\x00\xe1\xf5\x05\x00\x00\x00\x00\x16\x00\x14\xd0\xc4\xa3\xef\t\xe9\x97\xb6\xe9\x9e9~Q\x8f\xe3\xe4\x1a\x11\x8c\xa1"\x06\x02\xe7\xab%7\xb5\xd4\x9e\x97\x03\t\xaa\xe0n\x9eI\xf3l\xe1\xc9\xfe\xbb\xd4N\xc8\xe0\xd1\xcc\xa0\xb4\xf9\xc3\x19\x18s\xc5\xda\nT\x00\x00\x80\x01\x00\x00\x80\x00\x00\x00\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00"\x02\x03]I\xec\xcdT\xd0\t\x9eCgbw\xc7\xa6\xd4b]a\x1d\xa8\x8a]\xf4\x9b\xf9Qzw\x91\xa7w\xa5\x18s\xc5\xda\nT\x00\x00\x80\x01\x00\x00\x80\x00\x00\x00\x80\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00'
        
        TEST_PARTS_FORMAT_MULTIPART_UR = [
        # "ur:crypto-psbt/2-8/lpaoaycfadcycyamgrmswlhddkplkooncmswqdampahlvloyglaeaeaeaeaezczmzmzmaokefhhlahaeaeaeaecmaebbdleepktpcpnyde",
        # "ur:crypto-psbt/1-8/lpadaycfadcycyamgrmswlhddkhkadchjojkidjyzmadaejsaoaeaeaeadtkfnhdsrdtlfplcxgdlotarygawmndaopsurgtfswmwkinva",
        # "ur:crypto-psbt/3-8/lpaxaycfadcycyamgrmswlhddkcewtbkgupfgooemenbftkifewtolmklugmlamtmkaeaeaeaeaecmaebbvaimzezmsrlsmnjseylanegy",
        # "ur:crypto-psbt/4-8/lpaaaycfadcycyamgrmswlhddkwtoekgatvlpfbaueimvsvyhnaeaeaeaeaeadadctaevyykahaeaeaeaecmaebbtissotwsaskeisuold",
        # "ur:crypto-psbt/5-8/lpahaycfadcycyamgrmswlhddkwlmsrpwlnneskbgymyvlvecybylkoycpamaovdpydaemretynnmsaxaspkvtjtnngawfjzvychtbfxax",
        # "ur:crypto-psbt/6-8/lpamaycfadcycyamgrmswlhddksozerktyglspvtttsfnbqzytsrcfcsjksktnbkghaeaelaadaeaelaaeaeaelaaeaeaeaeaestwncstl",
        # "ur:crypto-psbt/7-8/lpataycfadcycyamgrmswlhddkaeaeaeaecpaoaxhlgawpsnghtiasnnfxioidktstoltyidhlhscapdlehlwkndytgyknktmevltdqzhn",
        # "ur:crypto-psbt/8-8/lpayaycfadcycyamgrmswlhddkosktoncsjksktnbkghaeaelaadaeaelaaeaeaelaadaeaeaeaeaeaeaeaeaeaeaeaeaeaeaefxktbtbb",
        
        # "UR:BYTES/9-4/LPASAACFADFXCYCMRTFYMNHDGYFWEEIDINEOGSFWEHFEJPGEECFPHKISFPIHEEHSJYGHFYFLJOJPKSHSFDJKIOHDFWGEFGFEGHJYEYIDJLKNEEGLFPEEHTEMFPHTGEJODLFNDYFREHFMDLDRDTDWJLJZIEIHJPDEEYDTDTDTCNESJSJNJNEEJPECKKAEVDGUYLLR",
        # "UR:BYTES/10-4/LPBKAACFADFXCYCMRTFYMNHDGYJOIOESKKGRHSGREEGEKKJLHSFWIMHFHKGEGRGOFGHDESGRIEKKIDEEIYIOFGHSFGGOGYJNHTGLFLGOEMEHGYEHKTHTIOHTINFLGTEHFLJLEMJOECESGLHGDLFNDYFREHFMDLDRDWHSJTIEHEKODEKOFTJOJEDEHPIHDYFSOTGH",
        # "UR:BYTES/10-4/LPBKAACFADFXCYCMRTFYMNHDGYJOIOESKKGRHSGREEGEKKJLHSFWIMHFHKGEGRGOFGHDESGRIEKKIDEEIYIOFGHSFGGOGYJNHTGLFLGOEMEHGYEHKTHTIOHTINFLGTEHFLJLEMJOECESGLHGDLFNDYFREHFMDLDRDWHSJTIEHEKODEKOFTJOJEDEHPIHDYFSOTGH",
        # "UR:BYTES/11-4/LPBDAACFADFXCYCMRTFYMNHDGYFWEEIDINEOGSFWEHFEJPGEECFPHKISFPIHEEHSJYGHFYFLJOJPKSHSFDJKIOHDFWGEFGFEGHJYEYIDJLKNEEGLFPEEHTEMFPHTGEJODLFNDYFREHFMDLDRDTDWJLJZIEIHJPDEEYDTDTDTCNESJSJNJNEEJPECKKAEFYTKSRRP",
        # "UR:BYTES/12-4/LPBNAACFADFXCYCMRTFYMNHDGYKGHGATHKAOKEJYCKJSGEJNCYJOKBFLJSFWCWGUGUASDYEMAHBEFNDIAXFHADFTJOETDLDIFTFZFXBKAEESKNLBDKLBBGIHASBYKKATHLGEKOFPHFINCYJZGYCAFHENHGECFZJSADIOKSLBBBJYDSAYGHLBGRHLECEEDIKOFMLF",
        # "UR:BYTES/12-4/LPBNAACFADFXCYCMRTFYMNHDGYKGHGATHKAOKEJYCKJSGEJNCYJOKBFLJSFWCWGUGUASDYEMAHBEFNDIAXFHADFTJOETDLDIFTFZFXBKAEESKNLBDKLBBGIHASBYKKATHLGEKOFPHFINCYJZGYCAFHENHGECFZJSADIOKSLBBBJYDSAYGHLBGRHLECEEDIKOFMLF",
        # "UR:BYTES/13-4/LPBTAACFADFXCYCMRTFYMNHDGYESIAIHDYEHDYENDLEEETDIDLEHDIDLDYDIDLEYDIHLJYJOKPIDFYFGGRGSIYIDEYJPINIDJTEEJSISJLFXGLEHIHGRFDGMFDGREOKTJPKOFGKNIOHGECFGKSEHGDHTEOGDEYHKEOGLGYHFEMGTHGIHESGRESISGSEENYFYFXMT",
        # "UR:BYTES/13-4/LPBTAACFADFXCYCMRTFYMNHDGYESIAIHDYEHDYENDLEEETDIDLEHDIDLDYDIDLEYDIHLJYJOKPIDFYFGGRGSIYIDEYJPINIDJTEEJSISJLFXGLEHIHGRFDGMFDGREOKTJPKOFGKNIOHGECFGKSEHGDHTEOGDEYHKEOGLGYHFEMGTHGIHESGRESISGSEENYFYFXMT",
        # "UR:BYTES/14-4/LPBAAACFADFXCYCMRTFYMNHDGYEYGUHPBEKSDPASAHBSBDDAGHAXEOFMCSDLLBEEEYBNKIBNBBBDCYGODMBBCLESAACTCHDEBAFTKPEMHDGRIHLBENJTFSJNDECAATFPISGUATGRAAATHSKIAMBEHEHGGOHPHLAOCKFDFLGTKEGWHKCWHGFYCFCACPIHFZLOPKKE",
        # "UR:BYTES/14-4/LPBAAACFADFXCYCMRTFYMNHDGYEYGUHPBEKSDPASAHBSBDDAGHAXEOFMCSDLLBEEEYBNKIBNBBBDCYGODMBBCLESAACTCHDEBAFTKPEMHDGRIHLBENJTFSJNDECAATFPISGUATGRAAATHSKIAMBEHEHGGOHPHLAOCKFDFLGTKEGWHKCWHGFYCFCACPIHFZLOPKKE",
        # "UR:BYTES/15-4/LPBSAACFADFXCYCMRTFYMNHDGYFWEEIDINEOGSFWEHFEJPGEECFPHKISFPIHEEHSJYGHFYFLJOJPKSHSFDJKIOHDFWGEFGFEGHJYEYIDJLKNEEGLFPEEHTEMFPHTGEJODLFNDYFREHFMDLDRDTDWJLJZIEIHJPDEEYDTDTDTCNESJSJNJNEEJPECKKAETPLNPMMU",
        # "UR:BYTES/15-4/LPBSAACFADFXCYCMRTFYMNHDGYFWEEIDINEOGSFWEHFEJPGEECFPHKISFPIHEEHSJYGHFYFLJOJPKSHSFDJKIOHDFWGEFGFEGHJYEYIDJLKNEEGLFPEEHTEMFPHTGEJODLFNDYFREHFMDLDRDTDWJLJZIEIHJPDEEYDTDTDTCNESJSJNJNEEJPECKKAETPLNPMMU",
        # "UR:BYTES/16-4/LPBEAACFADFXCYCMRTFYMNHDGYEYGUHPBEKSDPASAHBSBDDAGHAXEOFMCSDLLBEEEYBNKIBNBBBDCYGODMBBCLESAACTCHDEBAFTKPEMHDGRIHLBENJTFSJNDECAATFPISGUATGRAAATHSKIAMBEHEHGGOHPHLAOCKFDFLGTKEGWHKCWHGFYCFCACPIHLAAYMKEM",
        # "UR:BYTES/16-4/LPBEAACFADFXCYCMRTFYMNHDGYEYGUHPBEKSDPASAHBSBDDAGHAXEOFMCSDLLBEEEYBNKIBNBBBDCYGODMBBCLESAACTCHDEBAFTKPEMHDGRIHLBENJTFSJNDECAATFPISGUATGRAAATHSKIAMBEHEHGGOHPHLAOCKFDFLGTKEGWHKCWHGFYCFCACPIHLAAYMKEM",
        # "UR:BYTES/17-4/LPBYAACFADFXCYCMRTFYMNHDGYJPEHKBGHFRECIECEBAGOHNGWADJPJYATFNISCLFTHNDMGUGYGLJSCLFWAHEODNFXBSFTBNDPETINDAHYINGTAOECJLDAKBHKAHFZJOJLHEEMGOCXIHFNGWBBFZFWHKBZHLBABDKBFLKEISDRIMINFRHTJZBGENCNAMCSBGAYFR",
        # "UR:BYTES/17-4/LPBYAACFADFXCYCMRTFYMNHDGYJPEHKBGHFRECIECEBAGOHNGWADJPJYATFNISCLFTHNDMGUGYGLJSCLFWAHEODNFXBSFTBNDPETINDAHYINGTAOECJLDAKBHKAHFZJOJLHEEMGOCXIHFNGWBBFZFWHKBZHLBABDKBFLKEISDRIMINFRHTJZBGENCNAMCSBGAYFR",
        # "UR:BYTES/18-4/LPBGAACFADFXCYCMRTFYMNHDGYJPEHKBGHFRECIECEBAGOHNGWADJPJYATFNISCLFTHNDMGUGYGLJSCLFWAHEODNFXBSFTBNDPETINDAHYINGTAOECJLDAKBHKAHFZJOJLHEEMGOCXIHFNGWBBFZFWHKBZHLBABDKBFLKEISDRIMINFRHTJZBGENCNAMWDFZDSBE",
        # "UR:BYTES/18-4/LPBGAACFADFXCYCMRTFYMNHDGYJPEHKBGHFRECIECEBAGOHNGWADJPJYATFNISCLFTHNDMGUGYGLJSCLFWAHEODNFXBSFTBNDPETINDAHYINGTAOECJLDAKBHKAHFZJOJLHEEMGOCXIHFNGWBBFZFWHKBZHLBABDKBFLKEISDRIMINFRHTJZBGENCNAMWDFZDSBE",
        # "UR:BYTES/19-4/LPBWAACFADFXCYCMRTFYMNHDGYBDDYFMCXGACAFHDRFREOAOKGEYBBBYDEAYGDAMBZGYASKEHSINHYBWIHHDFLHPENJNKBGEHNBAAAHEEMAYDNGLGUDAKPFHHNHFEEENCYDAFPEHIAGDGHFRKBCLBSBTIYBDJLHPDPAMCMCWGRAOBAKBJTBSCXKPJTGYLBYABDDS",
        # "UR:BYTES/19-4/LPBWAACFADFXCYCMRTFYMNHDGYBDDYFMCXGACAFHDRFREOAOKGEYBBBYDEAYGDAMBZGYASKEHSINHYBWIHHDFLHPENJNKBGEHNBAAAHEEMAYDNGLGUDAKPFHHNHFEEENCYDAFPEHIAGDGHFRKBCLBSBTIYBDJLHPDPAMCMCWGRAOBAKBJTBSCXKPJTGYLBYABDDS",
        # "UR:BYTES/20-4/LPBBAACFADFXCYCMRTFYMNHDGYEYGUHPBEKSDPASAHBSBDDAGHAXEOFMCSDLLBEEEYBNKIBNBBBDCYGODMBBCLESAACTCHDEBAFTKPEMHDGRIHLBENJTFSJNDECAATFPISGUATGRAAATHSKIAMBEHEHGGOHPHLAOCKFDFLGTKEGWHKCWHGFYCFCACPIHCEFPYNBG",
        # "UR:BYTES/20-4/LPBBAACFADFXCYCMRTFYMNHDGYEYGUHPBEKSDPASAHBSBDDAGHAXEOFMCSDLLBEEEYBNKIBNBBBDCYGODMBBCLESAACTCHDEBAFTKPEMHDGRIHLBENJTFSJNDECAATFPISGUATGRAAATHSKIAMBEHEHGGOHPHLAOCKFDFLGTKEGWHKCWHGFYCFCACPIHCEFPYNBG",
        # "UR:BYTES/21-4/LPBZAACFADFXCYCMRTFYMNHDGYKGHGATHKAOKEJYCKJSGEJNCYJOKBFLJSFWCWGUGUASDYEMAHBEFNDIAXFHADFTJOETDLDIFTFZFXBKAEESKNLBDKLBBGIHASBYKKATHLGEKOFPHFINCYJZGYCAFHENHGECFZJSADIOKSLBBBJYDSAYGHLBGRHLECEELDWEGSST",
        # "UR:BYTES/21-4/LPBZAACFADFXCYCMRTFYMNHDGYKGHGATHKAOKEJYCKJSGEJNCYJOKBFLJSFWCWGUGUASDYEMAHBEFNDIAXFHADFTJOETDLDIFTFZFXBKAEESKNLBDKLBBGIHASBYKKATHLGEKOFPHFINCYJZGYCAFHENHGECFZJSADIOKSLBBBJYDSAYGHLBGRHLECEELDWEGSST",

        "UR:CRYPTO-PSBT/2-12/LPAOBNCFBKHTCYBBYLRLREHDUTCAUEDTQDVOTBGTBTWDGDUYTOPLBWIOYKZOFWBZSEBGMSLAFSFYFZJLAHGUPYSBKPMUISRLPFECBTOTOLCLAAHPFLLGJYHFHDLTPKJTNLHGRKIELSBETPWPTYFDBWTNBGRTCLIMHDIAHGJOAYJLHHDLHYIMFHCSEYLPGOSSPTJECXGMPADLNSSWSNECLUMSZSNBWNTIMOFGVLDSVYCAATJLHNBAOSJOJTJKRLFNJTBGIHPSCXKTRLURAYPFHSSGWMONRTSSHKFECMJSLOCXAETNFLBGNYHGGLENFXBTOXZOOSVEFPRDCXBGJSCYBZDEJNTIFNDIFLZOBWREISNYJSDKRFFEEHEHZTBWFYTOSTZSSSLFWLCWUTRDGMNTHFPRRTFWBZSEBGMSLAFSFYFZJLAHGUPYSBKPMUISRLPFECBTOTOLCLAAHPFLLGJYCNGMTKSF",
        "UR:CRYPTO-PSBT/5-12/LPAHBNCFBKHTCYBBYLRLREHDUTADAEAEAECLCMISMDJPVOLUBSWEPTTBMKCEAOEMTAVWUEUYZESEJNVDBBFHISBKAOWEHLBZNEKPLTFSADHGRKIELSBETPWPTYFDBWTNBGRTCLIMHDIAHGJOAYJLHHDLHYIMFHCSEYLPGOSSPTJKSKTNBKDYAEAELAADAEAELAAEAEAELAAOAEAELAAEAEAEAEADAEAEAECLCMKTRLURAYPFHSSGWMONRTSSHKFECMJSLOCXAETNFLBGNYHGGLENFXBTOXZOOSVEFPFSADSBGLLPZMENIAKEJECYVEYTGRTBGUVDJEJNECETOLDSFSNDSSLSVYMKYAYNLGZCKNAOVSRSWZDYAEAELAADAEAELAAEAEAELAAOAEAELAAOAEAEAEADAEAEAEADCHCXBGMSLAFSFYFZJLAHGUPYSBKPMUISRLPFECBTOTOLCLAAKPLEBDSW",
        "UR:CRYPTO-PSBT/5-12/LPAHBNCFBKHTCYBBYLRLREHDUTADAEAEAECLCMISMDJPVOLUBSWEPTTBMKCEAOEMTAVWUEUYZESEJNVDBBFHISBKAOWEHLBZNEKPLTFSADHGRKIELSBETPWPTYFDBWTNBGRTCLIMHDIAHGJOAYJLHHDLHYIMFHCSEYLPGOSSPTJKSKTNBKDYAEAELAADAEAELAAEAEAELAAOAEAELAAEAEAEAEADAEAEAECLCMKTRLURAYPFHSSGWMONRTSSHKFECMJSLOCXAETNFLBGNYHGGLENFXBTOXZOOSVEFPFSADSBGLLPZMENIAKEJECYVEYTGRTBGUVDJEJNECETOLDSFSNDSSLSVYMKYAYNLGZCKNAOVSRSWZDYAEAELAADAEAELAAEAEAELAAOAEAELAAOAEAEAEADAEAEAEADCHCXBGMSLAFSFYFZJLAHGUPYSBKPMUISRLPFECBTOTOLCLAAKPLEBDSW",
        "UR:CRYPTO-PSBT/6-12/LPAMBNCFBKHTCYBBYLRLREHDUTHPFLLGJYHFHDLTPKJTNLADCSCXMSGELFCAGUJEAXGWTITOURKBZOKTDYLSSFIDZTHKAMHEGSNDTEKETERLSNHHNDEOAEADAHCXPRLGQZEYDYMHFSWELFYAURVLOTTLPLVLRNPMLOVLJLPTPFVAKSMHWFHGRNJLWYCNCLATJSCTRPHSMDMUZOSOLFURCSNETBGDTDCWIDRFYLCNTEUTRYKKEMVEASPLIMNDWDAAFSADFWJPWNVDWZTEHHKEPEADSWBYLFDYUEBAHLFWHSGSKEDSLUHNNLEOLUHHLFGUBAROAOVSRSWZDYAEAELAADAEAELAAEAEAELAAOAEAELAAEAEAEAEAXAEAEAECLATLGBBNBCLJZJLPEAODERDRDLOMTZCDPJELEWDAMLATKVDCMVWTIGSNNEHGYLFWSJZFSADHPJNLSKOSEKOUOGHRLRHSWQZ",
        "UR:CRYPTO-PSBT/6-12/LPAMBNCFBKHTCYBBYLRLREHDUTHPFLLGJYHFHDLTPKJTNLADCSCXMSGELFCAGUJEAXGWTITOURKBZOKTDYLSSFIDZTHKAMHEGSNDTEKETERLSNHHNDEOAEADAHCXPRLGQZEYDYMHFSWELFYAURVLOTTLPLVLRNPMLOVLJLPTPFVAKSMHWFHGRNJLWYCNCLATJSCTRPHSMDMUZOSOLFURCSNETBGDTDCWIDRFYLCNTEUTRYKKEMVEASPLIMNDWDAAFSADFWJPWNVDWZTEHHKEPEADSWBYLFDYUEBAHLFWHSGSKEDSLUHNNLEOLUHHLFGUBAROAOVSRSWZDYAEAELAADAEAELAAEAEAELAAOAEAELAAEAEAEAEAXAEAEAECLATLGBBNBCLJZJLPEAODERDRDLOMTZCDPJELEWDAMLATKVDCMVWTIGSNNEHGYLFWSJZFSADHPJNLSKOSEKOUOGHRLRHSWQZ",
        "UR:CRYPTO-PSBT/7-12/LPATBNCFBKHTCYBBYLRLREHDUTONDLDWDPOXBNINFSWKTATTETVTGWMTLFESLTNDNSMTFYJYPKJKSKTNBKDYAEAELAADAEAELAAEAEAELAAOAEAELAAOAEAEAEAXAEAEAECLATMUGSEOSGBYIADEFSSKWELEGMJZZEKNTENNWDTODTBNLKVOZMKKAXHNHPWDLBFHDMFSADHPJNLSKOSEKOUOGHONDLDWDPOXBNINFSWKTATTETVTGWMTLFESLTNDNSMTFYJYPKAOVSRSWZDYAEAELAADAEAELAAEAEAELAAOAEAELAAOAEAEAEAXAEAEAECLATPAOYECTLDRMDCKADAEVOSWGSSGTPTAMOHDGTAXGYRHTNKGKIGLVOWNSGTTDSPDAAFSADFWJPWNVDWZTEHHKEPEADSWBYLFDYUEBAHLFWHSGSKEDSLUHNNLEOLUHHLFGUBAROJKSKTNBKDYWSTDPEHG",
        "UR:CRYPTO-PSBT/7-12/LPATBNCFBKHTCYBBYLRLREHDUTONDLDWDPOXBNINFSWKTATTETVTGWMTLFESLTNDNSMTFYJYPKJKSKTNBKDYAEAELAADAEAELAAEAEAELAAOAEAELAAOAEAEAEAXAEAEAECLATMUGSEOSGBYIADEFSSKWELEGMJZZEKNTENNWDTODTBNLKVOZMKKAXHNHPWDLBFHDMFSADHPJNLSKOSEKOUOGHONDLDWDPOXBNINFSWKTATTETVTGWMTLFESLTNDNSMTFYJYPKAOVSRSWZDYAEAELAADAEAELAAEAEAELAAOAEAELAAOAEAEAEAXAEAEAECLATPAOYECTLDRMDCKADAEVOSWGSSGTPTAMOHDGTAXGYRHTNKGKIGLVOWNSGTTDSPDAAFSADFWJPWNVDWZTEHHKEPEADSWBYLFDYUEBAHLFWHSGSKEDSLUHNNLEOLUHHLFGUBAROJKSKTNBKDYWSTDPEHG",
        "UR:CRYPTO-PSBT/9-12/LPASBNCFBKHTCYBBYLRLREHDUTGDTDCWIDRFYLCNTEUTRYKKEMVEASPLIMNDWDAARDGMNSADRTIMCXLGBBNBCLJZJLPEAODERDRDLOMTZCDPJELEWDAMLATKVDCMVWTIGSNNEHGYLFWSJZPSCXMUGSEOSGBYIADEFSSKWELEGMJZZEKNTENNWDTODTBNLKVOZMKKAXHNHPWDLBFHDMRDCXRLGWPYBSVLKGLUPSLEEMDKNSFDYNKSTAIYRNLEMSSWKBCHMEMSIMBSAEBSCPTLEYRDGMNTHFPRAEAEADAHCXAHDLNDMOZELRDTVLGSCEBYATLBHNCLLKDMBKPKLRVLWZWPKEVOENBAQZNDVWECDYCLATAHDLNDMOZELRDTVLGSCEBYATLBHNCLLKDMBKPKLRVLWZWPKEVOENBAQZNDVWECDYBTAEKEFGCKHLADAEAEAEADAEAEAECLATINMWBNAEMYFDHS",
        "UR:CRYPTO-PSBT/9-12/LPASBNCFBKHTCYBBYLRLREHDUTGDTDCWIDRFYLCNTEUTRYKKEMVEASPLIMNDWDAARDGMNSADRTIMCXLGBBNBCLJZJLPEAODERDRDLOMTZCDPJELEWDAMLATKVDCMVWTIGSNNEHGYLFWSJZPSCXMUGSEOSGBYIADEFSSKWELEGMJZZEKNTENNWDTODTBNLKVOZMKKAXHNHPWDLBFHDMRDCXRLGWPYBSVLKGLUPSLEEMDKNSFDYNKSTAIYRNLEMSSWKBCHMEMSIMBSAEBSCPTLEYRDGMNTHFPRAEAEADAHCXAHDLNDMOZELRDTVLGSCEBYATLBHNCLLKDMBKPKLRVLWZWPKEVOENBAQZNDVWECDYCLATAHDLNDMOZELRDTVLGSCEBYATLBHNCLLKDMBKPKLRVLWZWPKEVOENBAQZNDVWECDYBTAEKEFGCKHLADAEAEAEADAEAEAECLATINMWBNAEMYFDHS",
        "UR:CRYPTO-PSBT/10-12/LPBKBNCFBKHTCYBBYLRLREHDUTLYSNPRCHPYLNFPSPRKCLNEGSPMSOBTWNGEONSEJZEHEHPSRLNEKEBYQZYNFSADTBNBWNOYLDVLLRASRNSGHFTSMSIODLIHQDLBNLKGLUDTNYKSHTWMAMNNBWURJYVOAOVSRSWZDYAEAELAADAEAELAAEAEAELAAOAEAELAAXAEAEAEADAEAEAECLATKEJTFTEHSRDNSBNNOEAHIEJKCPDTJZHPOTINENFHBWJTYAWYHTSBCLSPYTTLCKGDFSADAYRNIDHYLTIOKKLSIYFGOLGHWEAYSGKEFXBYNDAXFEGDMKBBNBGWUEAMENLBZOAYAOVSRSWZDYAEAELAADAEAELAAEAEAELAAOAEAELAADAEAEAEADAEAEAECLATNDBEECRFRDCWMTJLZMENOESEPAGMEMRFNLGYRHMEHTJPRYWKDADLPLHENYAYREZMPSDIRELN",
        "UR:CRYPTO-PSBT/11-12/LPBDBNCFBKHTCYBBYLRLREHDUTFSADTBNBWNOYLDVLLRASRNSGHFTSMSIODLIHQDLBNLKGLUDTNYKSHTWMAMNNBWURJYVOLKQDJEETDYAEAELAADAEAELAAEAEAELAAOAEAELAADAEAEAEADAEAEAECLATVAJPLPVDHHLEVWJYFWMHWSURDPFXBBLELETEKGTNHPCLWFLDWNHDFROLVADEMTWYFSADTBNBWNOYLDVLLRASRNSGHFTSMSIODLIHQDLBNLKGLUDTNYKSHTWMAMNNBWURJYVOJKSKTNBKDYAEAELAADAEAELAAEAEAELAAOAEAELAAXAEAEAEADAEAEAECLATYNJZDYNBKIRFZCHSVDSKRPZSTKGLJZDIYTFLRDZSSBQDZTBAOELYVTCMKBJTMWLGFSADAYRNIDHYLTIOKKLSIYFGOLGHWEAYSGKEFXBYNDAXFEGDMKBBNBGWUEWPHTGEAX",
        "UR:CRYPTO-PSBT/12-12/LPBNBNCFBKHTCYBBYLRLREHDUTAMENLBZOAYJKSKTNBKDYAEAELAADAEAELAAEAEAELAAOAEAELAADAEAEAEADAEAEAEADAMRPADRTFGCXYNJZDYNBKIRFZCHSVDSKRPZSTKGLJZDIYTFLRDZSSBQDZTBAOELYVTCMKBJTMWLGPSCXKEJTFTEHSRDNSBNNOEAHIEJKCPDTJZHPOTINENFHBWJTYAWYHTSBCLSPYTTLCKGDRDGMNSADRTIMCXVAJPLPVDHHLEVWJYFWMHWSURDPFXBBLELETEKGTNHPCLWFLDWNHDFROLVADEMTWYPSCXINMWBNLYSNPRCHPYLNFPSPRKCLNEGSPMSOBTWNGEONSEJZEHEHPSRLNEKEBYQZYNRDCXNDBEECRFRDCWMTJLZMENOESEPAGMEMRFNLGYRHMEHTJPRYWKDADLPLHENYAYREZMRDGMNTHFPRAEAEAELPUOIEAT",
        "UR:CRYPTO-PSBT/12-12/LPBNBNCFBKHTCYBBYLRLREHDUTAMENLBZOAYJKSKTNBKDYAEAELAADAEAELAAEAEAELAAOAEAELAADAEAEAEADAEAEAEADAMRPADRTFGCXYNJZDYNBKIRFZCHSVDSKRPZSTKGLJZDIYTFLRDZSSBQDZTBAOELYVTCMKBJTMWLGPSCXKEJTFTEHSRDNSBNNOEAHIEJKCPDTJZHPOTINENFHBWJTYAWYHTSBCLSPYTTLCKGDRDGMNSADRTIMCXVAJPLPVDHHLEVWJYFWMHWSURDPFXBBLELETEKGTNHPCLWFLDWNHDFROLVADEMTWYPSCXINMWBNLYSNPRCHPYLNFPSPRKCLNEGSPMSOBTWNGEONSEJZEHEHPSRLNEKEBYQZYNRDCXNDBEECRFRDCWMTJLZMENOESEPAGMEMRFNLGYRHMEHTJPRYWKDADLPLHENYAYREZMRDGMNTHFPRAEAEAELPUOIEAT",
        "UR:CRYPTO-PSBT/13-12/LPBTBNCFBKHTCYBBYLRLREHDUTLRPTTKVTWMJKGTTAVATOCTFNJEFPJZKGGHFYWSOXZSPKHNFZEYDKSWGRGDLSKBIYKGDYBWPSYNIYSBGHTTNSEMRLESQDOLMDISSSJYMHSSKSHLWMNSTACLPEHKCPAAPFVAMKSNTSMKDYGHFXPMKBSNVTIOVYGAKGMWNEETGSKNFPSSOTBWFDHDLNAHCKJOLSMDFDGRTYGTPMWYBSCLLTURGDYKPSMKWSCYVYCWYTVTPRTSIDUTLYLATSLSMHPDLPHGYLLDBEBNHLDRLAMNFNFEVSBNJTOXJOTKFPWFIETOIHEHFXADTNBKSAWZKNJPFEMOYLPTCFVDMOAMTLESWKGDPTFHSWYNHDNDJPDAAEPATARPHGDADNWFOLCHWZLNTDMDEHKEVLKKIYWSZSLTEYESJSVALEOEWPTNDSEHPSWYDKIMZEIYLUSEJTDPMUQDBEHS",
        "UR:CRYPTO-PSBT/13-12/LPBTBNCFBKHTCYBBYLRLREHDUTLRPTTKVTWMJKGTTAVATOCTFNJEFPJZKGGHFYWSOXZSPKHNFZEYDKSWGRGDLSKBIYKGDYBWPSYNIYSBGHTTNSEMRLESQDOLMDISSSJYMHSSKSHLWMNSTACLPEHKCPAAPFVAMKSNTSMKDYGHFXPMKBSNVTIOVYGAKGMWNEETGSKNFPSSOTBWFDHDLNAHCKJOLSMDFDGRTYGTPMWYBSCLLTURGDYKPSMKWSCYVYCWYTVTPRTSIDUTLYLATSLSMHPDLPHGYLLDBEBNHLDRLAMNFNFEVSBNJTOXJOTKFPWFIETOIHEHFXADTNBKSAWZKNJPFEMOYLPTCFVDMOAMTLESWKGDPTFHSWYNHDNDJPDAAEPATARPHGDADNWFOLCHWZLNTDMDEHKEVLKKIYWSZSLTEYESJSVALEOEWPTNDSEHPSWYDKIMZEIYLUSEJTDPMUQDBEHS",
        "UR:CRYPTO-PSBT/14-12/LPBABNCFBKHTCYBBYLRLREHDUTCAUEDTQDVOTBGTBTWDGDUYTOPLBWIOYKZOFWBZSEBGMSLAFSFYFZJLAHGUPYSBKPMUISRLPFECBTOTOLCLAAHPFLLGJYHFHDLTPKJTNLHGRKIELSBETPWPTYFDBWTNBGRTCLIMHDIAHGJOAYJLHHDLHYIMFHCSEYLPGOSSPTJECXGMPADLNSSWSNECLUMSZSNBWNTIMOFGVLDSVYCAATJLHNBAOSJOJTJKRLFNJTBGIHPSCXKTRLURAYPFHSSGWMONRTSSHKFECMJSLOCXAETNFLBGNYHGGLENFXBTOXZOOSVEFPRDCXBGJSCYBZDEJNTIFNDIFLZOBWREISNYJSDKRFFEEHEHZTBWFYTOSTZSSSLFWLCWUTRDGMNTHFPRRTFWBZSEBGMSLAFSFYFZJLAHGUPYSBKPMUISRLPFECBTOTOLCLAAHPFLLGJYTNJLFPKO",
        "UR:CRYPTO-PSBT/14-12/LPBABNCFBKHTCYBBYLRLREHDUTCAUEDTQDVOTBGTBTWDGDUYTOPLBWIOYKZOFWBZSEBGMSLAFSFYFZJLAHGUPYSBKPMUISRLPFECBTOTOLCLAAHPFLLGJYHFHDLTPKJTNLHGRKIELSBETPWPTYFDBWTNBGRTCLIMHDIAHGJOAYJLHHDLHYIMFHCSEYLPGOSSPTJECXGMPADLNSSWSNECLUMSZSNBWNTIMOFGVLDSVYCAATJLHNBAOSJOJTJKRLFNJTBGIHPSCXKTRLURAYPFHSSGWMONRTSSHKFECMJSLOCXAETNFLBGNYHGGLENFXBTOXZOOSVEFPRDCXBGJSCYBZDEJNTIFNDIFLZOBWREISNYJSDKRFFEEHEHZTBWFYTOSTZSSSLFWLCWUTRDGMNTHFPRRTFWBZSEBGMSLAFSFYFZJLAHGUPYSBKPMUISRLPFECBTOTOLCLAAHPFLLGJYTNJLFPKO",
        "UR:CRYPTO-PSBT/15-12/LPBSBNCFBKHTCYBBYLRLREHDUTFSADTBNBWNOYLDVLLRASRNSGHFTSMSIODLIHQDLBNLKGLUDTNYKSHTWMAMNNBWURJYVOLKQDJEETDYAEAELAADAEAELAAEAEAELAAOAEAELAADAEAEAEADAEAEAECLATVAJPLPVDHHLEVWJYFWMHWSURDPFXBBLELETEKGTNHPCLWFLDWNHDFROLVADEMTWYFSADTBNBWNOYLDVLLRASRNSGHFTSMSIODLIHQDLBNLKGLUDTNYKSHTWMAMNNBWURJYVOJKSKTNBKDYAEAELAADAEAELAAEAEAELAAOAEAELAAXAEAEAEADAEAEAECLATYNJZDYNBKIRFZCHSVDSKRPZSTKGLJZDIYTFLRDZSSBQDZTBAOELYVTCMKBJTMWLGFSADAYRNIDHYLTIOKKLSIYFGOLGHWEAYSGKEFXBYNDAXFEGDMKBBNBGWUERKGLTKMD",
        "UR:CRYPTO-PSBT/15-12/LPBSBNCFBKHTCYBBYLRLREHDUTFSADTBNBWNOYLDVLLRASRNSGHFTSMSIODLIHQDLBNLKGLUDTNYKSHTWMAMNNBWURJYVOLKQDJEETDYAEAELAADAEAELAAEAEAELAAOAEAELAADAEAEAEADAEAEAECLATVAJPLPVDHHLEVWJYFWMHWSURDPFXBBLELETEKGTNHPCLWFLDWNHDFROLVADEMTWYFSADTBNBWNOYLDVLLRASRNSGHFTSMSIODLIHQDLBNLKGLUDTNYKSHTWMAMNNBWURJYVOJKSKTNBKDYAEAELAADAEAELAAEAEAELAAOAEAELAAXAEAEAEADAEAEAECLATYNJZDYNBKIRFZCHSVDSKRPZSTKGLJZDIYTFLRDZSSBQDZTBAOELYVTCMKBJTMWLGFSADAYRNIDHYLTIOKKLSIYFGOLGHWEAYSGKEFXBYNDAXFEGDMKBBNBGWUERKGLTKMD",
        "UR:CRYPTO-PSBT/16-12/LPBEBNCFBKHTCYBBYLRLREHDUTSPZTVYWSWLHTSRBTPMJNCMSKGMMEPEMYLGAYDWHKHLOTZEFXLSNTBTYKMTRSLBDYTNVTOXLDTTPFOLKIDLWMLUIMAAAETKVDBZIHTDGSRSRPSRTOUOOLRFFXRKJSTSCXKIFXSEDKVLQZWNSFVTFLNLLAGYHFOTNBVAAAJKHTCABNPLTEFZGELTZENTKBZCYKEOCLCFYNUEADIMWLGHGSDIAATOFPIOHPNSKPWYNTCSPLISWLMSMHWDFRVLPSPTBTVSQZSEFETNBDECNBATPENYBGZTAADTVLGWNSBWATHYVDMUDPCWURLYBYZCWFSNNLTDCMWKSFFHSBMHCESKMUBKBSDLOYUOFPCLJTDIRTJPPFRNJLSELBFHZODSESDNAXKBKEDWNLWYTNSALKBYWNBKBKOLEEKSECGMGWSPGTCSGDGRVSSGTBBWTTVODNGTNYZM",
        "UR:CRYPTO-PSBT/16-12/LPBEBNCFBKHTCYBBYLRLREHDUTSPZTVYWSWLHTSRBTPMJNCMSKGMMEPEMYLGAYDWHKHLOTZEFXLSNTBTYKMTRSLBDYTNVTOXLDTTPFOLKIDLWMLUIMAAAETKVDBZIHTDGSRSRPSRTOUOOLRFFXRKJSTSCXKIFXSEDKVLQZWNSFVTFLNLLAGYHFOTNBVAAAJKHTCABNPLTEFZGELTZENTKBZCYKEOCLCFYNUEADIMWLGHGSDIAATOFPIOHPNSKPWYNTCSPLISWLMSMHWDFRVLPSPTBTVSQZSEFETNBDECNBATPENYBGZTAADTVLGWNSBWATHYVDMUDPCWURLYBYZCWFSNNLTDCMWKSFFHSBMHCESKMUBKBSDLOYUOFPCLJTDIRTJPPFRNJLSELBFHZODSESDNAXKBKEDWNLWYTNSALKBYWNBKBKOLEEKSECGMGWSPGTCSGDGRVSSGTBBWTTVODNGTNYZM",
        "UR:CRYPTO-PSBT/17-12/LPBYBNCFBKHTCYBBYLRLREHDUTOTCFGUTBPSLBPSVDZEWLTTETHNGLMTLFRHLTNDNSCMFGJYPKWFSSTNBKDYADAELAADADAMENADRTFGNBWKJZDYCXLBRFZCHSVESKRPZSWYGAZMJESGLGPYNLVLMNESVLDETELKVSAARYBKIOIDASJOVOTPTORDDEPYSKFDKNHPHLCTDEEMENCXCTYLGATKFTHLSEKOVALPSSMHVSWDLDJEIMKEGLHFVSCFHSWLCFJSCSZEGWKOPKDLCAWSDPFXMWLULETEZOTNHPCLJKLUWNHDRKOXVADEMTWEPSCXINREBDDYJZLTSALYBWHESORKSRHKAEIOBYTYIABGVSSAFSLOWMTSSGTTNNVTKBDINSLONEDPEEZESPWDJSNTDWIMUEJTPFMWDSFMPTMYRLSFCSBWWNLOAXOXTOSWPTLSWLKIWLHHDADAKTTNBKDYBAWKWLSP",
        "UR:CRYPTO-PSBT/18-12/LPBGBNCFBKHTCYBBYLRLREHDUTDKVONNFTBSLEDEYKGWYAGLJYGTLNNDJKJKCPHTWTOSKPTPCAWPRHSBRNSWFSADHFOYWNOYASVLLRASFMSPHFTSCHIHDLIHQDKENLKGLUAYNTWMCMTPSFMYJOYLGADIWSIDWENNTOKNTECKWMTODTLKLKVOZMYTADHNHPIMKEFHDMFSAEHPJNLSHGSWBKPRJTMWWPATVAFTPLJZHKLTZOYAGHRKWPZMQZAMMWYKIEKSCKRSLUSGBYIMWPHNFSADLORSIDHYATIOKKLSVAFYOLGHJNBKSGKEFXBGNDAXFEJSNEONADKNBDDWOTHSZSAYVTDMWFETVSTAMOTPGSAXGYESTNKGKITOVTWNSGGYDIPDAAFSAEFWJPWNSWYKFDGSGABWRKUTLTWETKVSPSNSWFEOKGRTRSTNTAAYINYTVYKOKOCLCMDWHETDRSTKLOIYCTNY",
        "UR:CRYPTO-PSBT/19-12/LPBWBNCFBKHTCYBBYLRLREHDUTCAUEDTQDVOTBGTBTWDGDUYTOPLBWIOYKZOFWBZSEBGMSLAFSFYFZJLAHGUPYSBKPMUISRLPFECBTOTOLCLAAHPFLLGJYHFHDLTPKJTNLHGRKIELSBETPWPTYFDBWTNBGRTCLIMHDIAHGJOAYJLHHDLHYIMFHCSEYLPGOSSPTJECXGMPADLNSSWSNECLUMSZSNBWNTIMOFGVLDSVYCAATJLHNBAOSJOJTJKRLFNJTBGIHPSCXKTRLURAYPFHSSGWMONRTSSHKFECMJSLOCXAETNFLBGNYHGGLENFXBTOXZOOSVEFPRDCXBGJSCYBZDEJNTIFNDIFLZOBWREISNYJSDKRFFEEHEHZTBWFYTOSTZSSSLFWLCWUTRDGMNTHFPRRTFWBZSEBGMSLAFSFYFZJLAHGUPYSBKPMUISRLPFECBTOTOLCLAAHPFLLGJYHHBNKIMH",
        "UR:CRYPTO-PSBT/19-12/LPBWBNCFBKHTCYBBYLRLREHDUTCAUEDTQDVOTBGTBTWDGDUYTOPLBWIOYKZOFWBZSEBGMSLAFSFYFZJLAHGUPYSBKPMUISRLPFECBTOTOLCLAAHPFLLGJYHFHDLTPKJTNLHGRKIELSBETPWPTYFDBWTNBGRTCLIMHDIAHGJOAYJLHHDLHYIMFHCSEYLPGOSSPTJECXGMPADLNSSWSNECLUMSZSNBWNTIMOFGVLDSVYCAATJLHNBAOSJOJTJKRLFNJTBGIHPSCXKTRLURAYPFHSSGWMONRTSSHKFECMJSLOCXAETNFLBGNYHGGLENFXBTOXZOOSVEFPRDCXBGJSCYBZDEJNTIFNDIFLZOBWREISNYJSDKRFFEEHEHZTBWFYTOSTZSSSLFWLCWUTRDGMNTHFPRRTFWBZSEBGMSLAFSFYFZJLAHGUPYSBKPMUISRLPFECBTOTOLCLAAHPFLLGJYHHBNKIMH",
        "UR:CRYPTO-PSBT/20-12/LPBBBNCFBKHTCYBBYLRLREHDUTINRLPFECDWRETOQZKORHSFLFNLZMMNCTRPJZPLTYVWOENTVTNSJNVDBBFHINBKAOWEKEAXQDPATLHKCMHSNYBSGAFDFYVTBZGADNATFEQDJPCTJEZOVEIDMWKNFGUYCLMUASLEBSLRAOLBSNWTTLAOVAVEFDBWHTBWRTCLWDHDIAHGWTBKJLHHPEHYIMFHCSEOLPGOSSLOBBNEAYDPETPFHSGEWDONRTFYHKFECMWNLECXAEHTFLBGNYHGGWENFXBTLPWEYKGOJTOYSTAMKGBAISSFSRLGRKLOOECYJNEMGLVTAABTFRNETBFDGLDWYAWEWFZCSKYLFGQDZMZCUEUOMNHPCYVEKKGETBGUIOJEJNECROOXDSFSCWSWLSVYMKYTYNLGZCKGIEVWSPNTPFFSFYRTJTAHGUDNSBKPMUVSREPFECLGOYOLCLAAKOZTESSF",
        "UR:CRYPTO-PSBT/20-12/LPBBBNCFBKHTCYBBYLRLREHDUTINRLPFECDWRETOQZKORHSFLFNLZMMNCTRPJZPLTYVWOENTVTNSJNVDBBFHINBKAOWEKEAXQDPATLHKCMHSNYBSGAFDFYVTBZGADNATFEQDJPCTJEZOVEIDMWKNFGUYCLMUASLEBSLRAOLBSNWTTLAOVAVEFDBWHTBWRTCLWDHDIAHGWTBKJLHHPEHYIMFHCSEOLPGOSSLOBBNEAYDPETPFHSGEWDONRTFYHKFECMWNLECXAEHTFLBGNYHGGWENFXBTLPWEYKGOJTOYSTAMKGBAISSFSRLGRKLOOECYJNEMGLVTAABTFRNETBFDGLDWYAWEWFZCSKYLFGQDZMZCUEUOMNHPCYVEKKGETBGUIOJEJNECROOXDSFSCWSWLSVYMKYTYNLGZCKGIEVWSPNTPFFSFYRTJTAHGUDNSBKPMUVSREPFECLGOYOLCLAAKOZTESSF",
        "UR:CRYPTO-PSBT/21-12/LPBZBNCFBKHTCYBBYLRLREHDUTRHPDNLFPCYTDFYFTIDSTCLWKFSMTKGCEKGCLHHTPIATTWMFDPEWYBYBBIEDPZCLRVOGDIORTKBZCDMZSEYOENDFHTNHHBSDAMNFNVAIAMUFGEOAHRSTYCXTECTFNKSRLAEWDFDEOSSRDPACMVSHKJNMWFEFPDSKNPRSWJYPRRYDESEGMFRKOUTPKJYWTMKKNESUEYLKGRFAXFEESMSQDHNSETOYAKKGAFXHDZTCNHFVWJSWSGRMHVDSPHHURLSRDJZLSKSWPGYSFLNCMSGSPWYIERSLPNSFZTKSEJSIHTOVWPRFXADTNLURTWZKNTEFWIENDNLRDNYDMZORETPLTVDMURPPDDNUEHGVTREJLIEJEGERKFPVATAISPFBAGEBGPYHSSNLTHNFEDSLBBSKGMNBYVSTNVLSSHSFESSUOVTQZTYIOKEFZKKRNDAOYMEGTNB",
        "UR:CRYPTO-PSBT/22-12/LPCMBNCFBKHTCYBBYLRLREHDUTISRLPFECBTOTOLCLAAHPFLLGJYHFHDLTPKJTNLBTAEKEFGCKHLAEAEAEAEADAEAEAECLCMDWSSGMIECHENCLJESGHDNSBNSEADETUTHGJKGUKPEOMKQDBGNSBZCYWKLBYTENMOFSADHGRKIELSBETPWPTYFDBWTNBGRTCLIMHDIAHGJOAYJLHHDLHYIMFHCSEYLPGOSSPTAOVSRSWZDYAEAELAADAEAELAAEAEAELAAOAEAELAAEAEAEAEADAEAEAECLCMGMPADLNSSWSNECLUMSZSNBWNTIMOFGVLDSVYCAATJLHNBAOSJOJTJKRLFNJTBGIHFSADSBGLLPZMENIAKEJECYVEYTGRTBGUVDJEJNECETOLDSFSNDSSLSVYMKYAYNLGZCKNJKSKTNBKDYAEAELAADAEAELAAEAEAELAAOAEAELAAOAEAEAEVYWSDWJY",
        "UR:CRYPTO-PSBT/23-12/LPCHBNCFBKHTCYBBYLRLREHDUTHNDTROWTTDMWSRBNWYBNCTURISCPLYCMCHTIFSCXGHKPLYTSFSLRJTTYRYRYGTGDPFLABEDSTKHHRDDMATFNSOFZBDSFGASNLPJPJEOLTPDAGULOWMGHWYGAETHYFZPALTWMNNUENLVTFXBBEYCLMSBARYGTZMLREEOXLRGESOSACKHGFXLBSOUOMYAOSOLFPDFSNSSNBWIEDMRLVALYBWHGSSDKSRAOHKHDUYAEUODTZSHDWEFZLKWTDMWPDMNEDRBTTSWZZEMSNLLGVALUTOWPHELSPSKSGMSPWKWEWYMKIMRDOTFSCLAABYNYZSDLCSDRJSQZRNJNHHDMVWVAFWSFUYCKOSCWHHRFVYSRSOCNETLRJEUTJEYKKONBMNCHFGVSZOLTFZCNQDENLECFDSHSHSRLWMMUDWAXPMRSIDBYRPLPRNCYMWLUWSBZGUDMSR",
        "UR:CRYPTO-PSBT/25-12/LPCSCFBNCFBKHTCYBBYLRLREHDUTADAEAEAECLCMISMDJPVOLUBSWEPTTBMKCEAOEMTAVWUEUYZESEJNVDBBFHISBKAOWEHLBZNEKPLTFSADHGRKIELSBETPWPTYFDBWTNBGRTCLIMHDIAHGJOAYJLHHDLHYIMFHCSEYLPGOSSPTJKSKTNBKDYAEAELAADAEAELAAEAEAELAAOAEAELAAEAEAEAEADAEAEAECLCMKTRLURAYPFHSSGWMONRTSSHKFECMJSLOCXAETNFLBGNYHGGLENFXBTOXZOOSVEFPFSADSBGLLPZMENIAKEJECYVEYTGRTBGUVDJEJNECETOLDSFSNDSSLSVYMKYAYNLGZCKNAOVSRSWZDYAEAELAADAEAELAAEAEAELAAOAEAELAAOAEAEAEADAEAEAEADCHCXBGMSLAFSFYFZJLAHGUPYSBKPMUISRLPFECBTOTOLCLAAMYGWSGIE",
        "UR:CRYPTO-PSBT/26-12/LPCSCYBNCFBKHTCYBBYLRLREHDUTBSGMTITNCAZORSPALRZMLFHSKEJECYVWLNLYGMTOFMWYREFGMEWDHHLABASEVYZEOXGAAHLKSTLBDPWEASPLQDJLAXFDPAHDTBMKCEAOEMDKCYCLDKZCVYSFVTBBFHISBKAOTKBNECCSDTROMSCWPSTYMONYBYTLZCNBNBRENSSPHPBNPTVOTNPFGASSWLRYLOCSYTNEMKQZFSYNENMORDGMNSVOJOENMKFXTLJZGOWSOLVAYNNTGDGMZOVOHGLGJZGADAWYPSKPJYJNFPRNHKWEJSPMZSCKVDLASFGLLPZMENIAHYFTFTYNOTWYAAMTJZESONGRLPDNNTCXTISOPEBDLOBKVTSGIHWDWMMYVLNSFNGDDILBFRAEAELAAEAEADLYDTVWJTNNAEAEAEAEADCPGYCXJPFSMHMYEEFPCHVONSBEVOYTLSONGDRSBSCTJE",
        "UR:CRYPTO-PSBT/26-12/LPCSCYBNCFBKHTCYBBYLRLREHDUTBSGMTITNCAZORSPALRZMLFHSKEJECYVWLNLYGMTOFMWYREFGMEWDHHLABASEVYZEOXGAAHLKSTLBDPWEASPLQDJLAXFDPAHDTBMKCEAOEMDKCYCLDKZCVYSFVTBBFHISBKAOTKBNECCSDTROMSCWPSTYMONYBYTLZCNBNBRENSSPHPBNPTVOTNPFGASSWLRYLOCSYTNEMKQZFSYNENMORDGMNSVOJOENMKFXTLJZGOWSOLVAYNNTGDGMZOVOHGLGJZGADAWYPSKPJYJNFPRNHKWEJSPMZSCKVDLASFGLLPZMENIAHYFTFTYNOTWYAAMTJZESONGRLPDNNTCXTISOPEBDLOBKVTSGIHWDWMMYVLNSFNGDDILBFRAEAELAAEAEADLYDTVWJTNNAEAEAEAEADCPGYCXJPFSMHMYEEFPCHVONSBEVOYTLSONGDRSBSCTJE",
        "UR:CRYPTO-PSBT/27-12/LPCSCWBNCFBKHTCYBBYLRLREHDUTAMENLBZOAYJKSKTNBKDYAEAELAADAEAELAAEAEAELAAOAEAELAADAEAEAEADAEAEAEADAMRPADRTFGCXYNJZDYNBKIRFZCHSVDSKRPZSTKGLJZDIYTFLRDZSSBQDZTBAOELYVTCMKBJTMWLGPSCXKEJTFTEHSRDNSBNNOEAHIEJKCPDTJZHPOTINENFHBWJTYAWYHTSBCLSPYTTLCKGDRDGMNSADRTIMCXVAJPLPVDHHLEVWJYFWMHWSURDPFXBBLELETEKGTNHPCLWFLDWNHDFROLVADEMTWYPSCXINMWBNLYSNPRCHPYLNFPSPRKCLNEGSPMSOBTWNGEONSEJZEHEHPSRLNEKEBYQZYNRDCXNDBEECRFRDCWMTJLZMENOESEPAGMEMRFNLGYRHMEHTJPRYWKDADLPLHENYAYREZMRDGMNTHFPRAEAEAEAOSTGLAT",
        "UR:CRYPTO-PSBT/28-12/LPCSCEBNCFBKHTCYBBYLRLREHDUTGDJTYAGYIYWDBAMWMYTKENIAZTIMCYVEKKGRTBGUIOINJNECROOSDSFSNDSKLSVYMKYTWTFRZTRDADAENNYTFWFWYNQDBESPEHHLPKYAYAMSLDYTCPRHKGMSDWOSSRIYPDLSBTGRJEWNVYBKAEAEGDPKISGOTYCAWDYKISHLYALBVLDEGHLNWKCYIHGECXYNGRZTSWUEFRFNLNDWDESAAEAEAESEVYKEEYMSISMHTKEHHTTAGUAHJEZTIMFETAIHPLENMTGEWMOSEYRLFLENOEZMDKBSEOGRTEPMWMDIBYWFRLPLTOKEPAIDROLSJNJPKSDIRTZTECHGJZMKHTPDPRTIEEGWINWNWPTOKNASGROTCXECRFFTCYMTJLLBENOESEEHGDEMRFCFGYRHMEHTJKRYWKDABAROGTBTLOLORKZSFSMKAHCFSBKPMUAYFWWZDK",

        # "UR:CRYPTO-PSBT/435-6/LPCFADQDAMCFADRNCYOYBKFRSNHDGRVAGOMNPRWDJNYAOLLPZTFXWMLPWSLTSRCKMWYAPLCMAOKONSEHNSMOLGAMBZEYISWLAODPKTRSMHPYESPMBAMDGDSONLVTCTDKCMADRSDPDSURIYCXNTCFGWLAAELAADQDDRTEBDLBRLKTUYKBFXLAPFDTNYIE",
        # "UR:CRYPTO-PSBT/436-6/LPCFADQZAMCFADRNCYOYBKFRSNHDGRSOJYHYAOAEAEAEAECMAEBBGHDPKEGHRDMYFGFGECSNDYEOHDDITEDWLUUEGOYAADAXAAADAEAEAECPAMAXSKFPSRAENYTEZEFDSKWTEOJSDPBZTYGDMOLNREKTDEKTCYAMIHSEVSJSMNMTDRDWCSIHJOPDGOHF",
        # "UR:CRYPTO-PSBT/437-6/LPCFADREAMCFADRNCYOYBKFRSNHDGRGSJTKOFYTKFZPDHNURCMWDBKFWTTFYNTMYFGFGECSNDYDAHDEOONUYFDHTPSYLNNEYJSKNSSKOPRSPTPSTJZLYJNOLIDFYZMFDLEWNEMFYPKTNTSLUGSHSPLYLDEKTCYREGWMOVLBAESHSWNGUHTZSMDVASBEY",
        # "UR:CRYPTO-PSBT/438-6/LPCFADRPAMCFADRNCYOYBKFRSNHDGRVLGLOLWKDADAGDSWGSWDNERLWLSENYZOIDVLINFYZOJTTOFPZMFYRFECHDPTIYRERPUYWSRTCMLSNEPLDALOFTLNJEKKBGVWIOOSGHRKCSCLBYIHZOSRZEGHAELALAADAEAELNAEAEAELAAEADADCTFTNLESVE",
        # "UR:CRYPTO-PSBT/438-6/LPCFADRPAMCFADRNCYOYBKFRSNHDGRVLGLOLWKDADAGDSWGSWDNERLWLSENYZOIDVLINFYZOJTTOFPZMFYRFECHDPTIYRERPUYWSRTCMLSNEPLDALOFTLNJEKKBGVWIOOSGHRKCSCLBYIHZOSRZEGHAELALAADAEAELNAEAEAELAAEADADCTFTNLESVE",
        # "UR:CRYPTO-PSBT/439-6/LPCFADRLAMCFADRNCYOYBKFRSNHDGRDIHDJNIDRFCPHHNNSPCMBSHHJLPMMHDSGWWSNDAXBBBZTNISNEVOURGOGAIODMKPSBBNASSOHEEHHGBEBBDEVOBNTSGHYTMEFGBDRNCTFDRNSPIYJTDLADGLRKYTFXZEVDDRFELUIMEYLAMEFMUTCELDNEEEAY",
        # "UR:CRYPTO-PSBT/440-6/LPCFADROAMCFADRNCYOYBKFRSNHDGRBEJYVWJPJKIMJYZMCHAEFLGHDMZMHKOXRFUEGSTAEEGAGYWEGHWMURLDJSBTSSNNHDWYAYAOMOAOGABBKNLAIDIOPMGELDBBBDFROXEOJSGDWMDNPEBEPKYADTPKKTCYAMIHTTVSIHBDVYVTJNLTVATDOSGWLO",
    ]

        def create_ur_decoder(force_python=False):
            """
            Factory function to create a URDecoder, preferring C implementation
            """
            if force_python:
                from ur.ur_decoder import URDecoder
                return URDecoder()
            try:
                # Try to use the C implementation first
                import bc_ur
                return bc_ur.URDecoder()
            except ImportError:
                # Fallback to Python implementation
                print("bc_ur module not found, using Python URDecoder")
                from ur.ur_decoder import URDecoder
                return URDecoder()

        def urobj_to_data(ur_obj):
            """returns flatened data from a UR object. belongs in qr or qr_capture???"""
            import urtypes

            if ur_obj.type == "crypto-bip39":
                data = urtypes.crypto.BIP39.from_cbor(ur_obj.cbor).words
            elif ur_obj.type == "crypto-account":
                data = (
                    urtypes.crypto.Account.from_cbor(ur_obj.cbor)
                    .output_descriptors[0]
                    .descriptor()
                )
            elif ur_obj.type == "crypto-output":
                data = urtypes.crypto.Output.from_cbor(ur_obj.cbor).descriptor()
            elif ur_obj.type == "crypto-psbt":
                data = urtypes.crypto.PSBT.from_cbor(ur_obj.cbor).data
            elif ur_obj.type == "bytes":
                data = urtypes.bytes.Bytes.from_cbor(ur_obj.cbor).data
            else:
                data = None
            return data

        import time

        print("Processing Blockchain Commons UR multipart benchmark test.")
        start_time = time.ticks_ms()

        # Test the integration
        decoder = create_ur_decoder()
        # print("Created decoder: {}".format(type(decoder)))

        # Test receiving parts
        result = None
        for part in TEST_PARTS_FORMAT_MULTIPART_UR:
            # print("Processing part: {}".format(part))
            success = decoder.receive_part(part)
            # print("Success: {}".format(success))
            # print("Progress: {:.1%}".format(decoder.estimated_percent_complete()))
            # print("Complete: {}".format(decoder.is_complete()))
            if decoder.is_complete():
                if decoder.is_success():
                    result = decoder.result
                    # print("Decoded UR: type={}, data_len={}".format(result.type, len(result.cbor)))
                else:
                    print("UR decoding failed")
                break
        
        from bc_ur import UR

        if result:
            # import binascii
            # from ..baseconv import base_encode

            # print("Decoded CBOR (hex):", binascii.hexlify(decoder.result.cbor).decode())
            ur_data = UR(decoder.result.type, bytearray(decoder.result.cbor))
            # print("UR Object data (hex):", binascii.hexlify(ur_data.cbor).decode())
            final_data = urobj_to_data(ur_data)
            # print("Final data type:", type(final_data))
            # print("Final data:", final_data)
            # print("Final data (base64):", base_encode(final_data, 64))

            end_time = time.ticks_ms()
            c_time = end_time - start_time
            # print("Data matches reference:", final_data == TEST_DATA_BYTES)
            print("C: {} ms".format(c_time))

        start_time = time.ticks_ms()
        
        decoder = create_ur_decoder(force_python=True)

        # Test receiving parts
        for part in TEST_PARTS_FORMAT_MULTIPART_UR:
            # print("Processing part: {}".format(part))
            success = decoder.receive_part(part)
            if not success:
                print("Failed to process part")
                continue

            if decoder.is_complete():
                from ur.ur import UR as URP

                # print("Python decoder output:",bytearray(decoder.result.cbor))
                ur_data = URP(decoder.result.type, bytearray(decoder.result.cbor))
                final_data_python = urobj_to_data(ur_data)
                # print("Final data python:", base_encode(final_data, 64))
                break

        end_time = time.ticks_ms()
        elapsed_time = end_time - start_time
        print("Python: {} ms".format(elapsed_time))
        print("Data matches:", final_data==final_data_python)
        
        
        import board
        from ..metadata import VERSION
        from ..qr import FORMAT_NONE

        title = "selfcustody.github.io/krux"
        msg = (
            title
            + "\n"
            + t("Hardware")
            + ": %s\n" % board.config["type"]
            + t("Version")
            + ": %s" % VERSION
        )
        offset_x = 0
        width = 0
        if kboard.is_cube:
            offset_x = self.ctx.display.width() // 4
            width = self.ctx.display.width() // 2
        self.display_qr_codes(
            title,
            FORMAT_NONE,
            msg,
            offset_x=offset_x,
            width=width,
            highlight_prefix=":",
        )
        return MENU_CONTINUE
